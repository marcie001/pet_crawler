# -*- encoding: UTF-8 -*-
require 'net/http'
require 'json'
require 'base64'
require 'date'
require 'digest/hmac'
require 'yaml'
require 'logger'

class TwitterClient

    RESERVED_CHARACTERS = /[^a-zA-Z0-9\-\.\_\~]/

    def initialize(oauth_consumer_key, oauth_consumer_secret)
        @rand = Random.new
        @logger = Logger.new(STDOUT)
        @oauth_version = '1.0'
        @oauth_consumer_key = oauth_consumer_key
        @oauth_consumer_secret = oauth_consumer_secret
        @version = '1.1'
    end

    def get_request_token(oauth_callback)
        uri = initialize_uri
        res = Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.port == 443) do |http|
            uri.path = "/oauth/request_token"
            header = convert_oauth_string(create_oauth_params(uri, 'POST', oauth_callback))
            post = Net::HTTP::Post.new uri.request_uri
            post['Authorization'] = header
            http.request post
        end

        case res
        when Net::HTTPSuccess
            values = res.body.split('&').map do |val|
                val.split '=' 
            end
            Hash[values]
        else
            @logger.error "#{res.class}\n#{res.body}"
            raise "twitter との通信に失敗しました。#{res.class}\n#{res.body}"
        end
    end

    def get_access_token(oauth_verifier = nil)
        uri = initialize_uri
        res = Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.port == 443) do |http|
            uri.path = "/oauth/access_token"
            request_params = unless oauth_verifier.nil? 
                {:oauth_verifier => oauth_verifier}
            else
              {}
            end
            header = convert_oauth_string(create_oauth_params(uri, 'POST', nil, request_params))
            post = Net::HTTP::Post.new uri.request_uri
            post['Authorization'] = header
            post.body = request_params.map {|k,v| k.to_s + '=' + v.to_s}.join('&')
            http.request post
        end

        case res
        when Net::HTTPSuccess
            values = res.body.split('&').map do |val|
                val.split '=' 
            end
            Hash[values]
        else
            @logger.error "#{res.class}\n#{res.body}"
            raise "twitter との通信に失敗しました。#{res.class}\n#{res.body}"
        end
    end

    def get_resource(resource, request_params = {})
        uri = initialize_uri
        res = Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.port == 443) do |http|
            uri.path = "/#{@version.to_s}/#{resource}.json"
            authorization = convert_oauth_string(create_oauth_params(uri, 'GET', nil, request_params))
            uri.query = request_params.map{|key, val| key.to_s + '=' + val.to_s}.join('&')
            get = Net::HTTP::Get.new uri.request_uri
            get['Authorization'] = authorization
            http.request get
        end
 
        case res
        when Net::HTTPSuccess
            JSON.parse(res.body)
        else
            @logger.error "#{res.class}\n#{res.body}"
            raise "twitter との通信に失敗しました。#{res.class}\n#{res.body}"
        end
    end

    def account=(account)
        @oauth_token = account[:oauth_token] || account['oauth_token']
        @oauth_token_secret = account[:oauth_token_secret] || account['oauth_token_secret']
    end

    private
    def initialize_uri
        URI('https://api.twitter.com/')
    end
    #
    # OAuth のパラメタを生成しマップで返す
    #
    def create_oauth_params(uri, method, oauth_callback = nil, request_params = {})
        oauth_params = {
            :oauth_callback => oauth_callback,
            :oauth_consumer_key => @oauth_consumer_key,
            :oauth_nonce => create_oauth_nonce,
            :oauth_signature_method => 'HMAC-SHA1',
            :oauth_timestamp => timestamp,
            :oauth_token => @oauth_token,
            :oauth_version => @oauth_version,
        }.select { |k,v| !v.nil? }
        params = oauth_params.merge request_params 
        oauth_params[:oauth_signature] = create_signature(method, uri.to_s, params)
        oauth_params
    end

    #
    # 引数のマップを OAuth ヘッダの値の文字列にする
    #
    def convert_oauth_string(oauth_params)
        'OAuth ' + oauth_params.map { |key, val| "#{percent_escape(key.to_s)}=\"#{percent_escape(val.to_s)}\"" }.join(', ')
    end

    #
    # oauth_nonce を生成する。
    # The oauth_nonce parameter is a unique token your application should generate for each unique request.
    # Twitter will use this value to determine whether a request has been submitted multiple times.
    # The value for this request was generated by base64 encoding 32 bytes of random data,
    # and stripping out all non-word characters, but any approach which produces a relatively random alphanumeric string should be OK here.
    #
    def create_oauth_nonce
        Base64.strict_encode64(@rand.bytes(32))
    end

    #
    # タイムスタンプを返す
    #
    def timestamp
        DateTime.now.strftime('%s')
    end

    #
    # signature を生成する
    # method: The request method will almost always be GET or POST for Twitter API requests.
    # base_url: The base URL is the URL to which the request is directed, minus any query string or hash parameters. It is important to use the correct protocol here, so make sure that the "https://" or "http://" portion of the URL matches the actual request sent to the API. As a best practice, you should always be using "https://" with the Twitter API.
    # parameters: all of the parameters included in the request
    #
    def create_signature(method, base_url, parameters)
        parameters_string = parameters.map do |key, val|
            [percent_escape(key), percent_escape(val)]
        end.sort.map do |key, val|
            key + '=' + val 
        end.join('&')
        str = method.to_s.upcase + '&' + percent_escape(base_url.to_s) + '&' + percent_escape(parameters_string)
        @logger.debug str
        sining_key = @oauth_consumer_secret + '&' + @oauth_token_secret.to_s
        Digest::HMAC.base64digest(str, sining_key, Digest::SHA1)
    end

    #
    # percent escape する
    #
    def percent_escape(value)
        URI::escape(value.to_s, RESERVED_CHARACTERS)
    rescue ArgumentError
        URI::escape(value.to_s.force_encoding(Encoding::UTF_8), RESERVED_CHARACTERS)
    end

end
